% Created 2014-11-11 Tue 14:48
\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{fixltx2e}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{marvosym}
\usepackage{wasysym}
\usepackage{amssymb}
\usepackage{hyperref}
\tolerance=1000
\usepackage[margin=1.5cm]{geometry}
\setcounter{secnumdepth}{2}
\author{Riley E.}
\date{\today}
\title{Common Lisp Chinese Vocabulary Drill.}
\hypersetup{
  pdfkeywords={},
  pdfsubject={},
  pdfcreator={Emacs 24.3.1 (Org mode 8.2.10)}}
\begin{document}

\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\begin{verbatim}
;; Copyright (C) 2014 Riley E.

;; This program is free software: you can redistribute it and/or
;; modify it under the terms of the GNU General Public License as
;; published by the Free Software Foundation, either version 3 of
;; the License, or (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public
;; License along with this program. If not, see
;; <http://www.gnu.org/licenses/>.
\end{verbatim}

\section{Headers, Variables, Parameters}
\label{sec-1}
\subsection{System description}
\label{sec-1-1}
The Chinese Vocab Drill software is written largely out of a desire for learning
more Common Lisp, better programming techniques, and the Chinese Mandarin
language. All editing is done in the .ORG file, and exported to .PDF, and the
source code is "tangled" from the code blocks into the appropriate .LISP
files. This package takes advantage of several libraries:
\begin{itemize}
\item \href{http://common-lisp.net/project/iterate/}{iterate}:
\begin{itemize}
\item The iterate package was written as a more Lispy and extensible alternative to
the standard LOOP macro.
\end{itemize}
\item \href{http://weitz.de/cl-ppcre/}{cl-ppcre}:
\begin{itemize}
\item A fast regular expression library, allows for sophisticated methods for
pattern matching, including creating of Scanners.
\end{itemize}
\item \href{http://common-lisp.net/project/external-program/}{external-program}:
\begin{itemize}
\item Allows an implementation-neutral access to external programs.
\end{itemize}
\item \href{http://common-lisp.net/project/bordeaux-threads/}{bordeaux-threads}
\begin{itemize}
\item a system for launching and managing threads as long as your Lisp system
provides support for them.
\end{itemize}
\end{itemize}

\subsection{System Definition}
\label{sec-1-2}
\begin{verbatim}
(asdf:defsystem #:cl-cvd
  :serial t
  :description "Chinese Vocabulary Drill"
  :author "Riley E."
  :license "GPLv3 or Later"
  :depends-on (:iterate :cl-ppcre :cl-csv :external-program :bordeaux-threads)
  :components ((:file "package")
	       (:file "cl-cvd")
	       (:file "csv-import")))
\end{verbatim}

\subsection{Package Definition}
\label{sec-1-3}
\begin{verbatim}
(defpackage #:chinese-vocab-drill
  (:nicknames #:cl-cvd)
  (:use :common-lisp
	:iterate
	:bordeaux-threads
	:cl-ppcre
	:cl-csv
	:external-program))
\end{verbatim}

\subsection{Global variables, and setting the package}
\label{sec-1-4}
Initialize the hash-table, and the hash-table element counter, which is used for
generating the keys used to identify hash-table entries.
\begin{verbatim}
  (in-package :cl-cvd)

;;; The constant PHI is used for spaced-repetition timing
  (defconstant phi 1.618033988749895d0
    "The constant PHI, The golden ratio.")

  (defvar *zh-hash-table* (make-hash-table)
    "Hash table for storing data of, and
  metadata about the vocabulary listing")

  (defvar *mp3dir* nil)

  (defvar *mp3-alist* nil)

  (defvar *vocab-key-count* 0
    "Counter for the list of vocabulary entries,
  is incremented on addition of elements, or set
  when a data-set is loaded into the hash-table.")

  (defvar *test-pool* nil
    "Words that have been seen during a practice session")

  (defvar *current-hsk-level* 1)
\end{verbatim}

\section{Structures}
\label{sec-2}
\begin{itemize}
\item Vocab Entry:
\begin{itemize}
\item The \texttt{vocab-entry} data-structure houses each vocabulary item, as well as the
metadata about each item, such as times correct, time incorrect, last
practice date, and repetitions.
\end{itemize}
\end{itemize}
\begin{verbatim}
(defstruct vocab-entry
  (hsk     1                    :type integer)
  (hanzi   ""                   :type string)
  (pinyin  ""                   :type string)
  (english '("")                :type list)
  (seealso '("")                :type list)
  (units   '("")                :type list)
  (score   (complex 0.0 0.0)    :type complex)
  (date    (get-universal-time) :type integer)
  (reps    1                    :type integer))
\end{verbatim}
\section{Comma-separated value import utilities}
\label{sec-3}
\subsection{Header info}
\label{sec-3-1}
\begin{verbatim}
;; This file is a part of the CL-CVD package, and contains the functionality for
;; parsing CSV input.
\end{verbatim}
\subsection{preprocess-english}
\label{sec-3-2}
Break up the generic English description rendered from the CSV by
splitting it at each semicolon.
\begin{verbatim}
(defun preprocess-english (desc-string)
  (car (cl-csv:read-csv desc-string
			:separator #\SEMICOLON)))
\end{verbatim}
\subsection{collect-measures}
\label{sec-3-3}
Collect all applicable notes concerning units of measurement related to words
and generate a list of them. First checking to see if the object is a string at
all, then if the length is greater than four (to prevent errors, and because it
is a waste of time to scan such strings), then if the string begins with the
characters which designate a unit (in this case, "CL:".)
\begin{verbatim}
(defun collect-measures (l)
  (iterate (for s in l)
    (when (and (stringp s)
	       (< 4 (length s))
	       (string= (subseq s 0 3) "CL:"))
      (collect s))))
\end{verbatim}
\subsection{clean-measures}
\label{sec-3-4}
Prune the "CL:" from the head of measures to make displaying nicer.
\begin{verbatim}
(defun clean-measures (s)
  (regex-replace "CL:" s ""))
\end{verbatim}
\subsection{flatten}
\label{sec-3-5}
Flatten nested lists. Pulled from \href{http://letoverlambda.com}{Let Over Lambda} Credit goes to Doug Hoyte.
\begin{verbatim}
(defun flatten (x)
  (labels ((rec (x acc)
	     (cond ((null x) acc)
		   ((atom x) (cons x acc))
		   (t (rec (car x)
			   (rec (cdr x) acc))))))
    (rec x nil)))
\end{verbatim}
\subsection{finalize-measures}
\label{sec-3-6}
Take the collected measures, split them by commas into separate
strings, and flatten the resulting structure.
\begin{verbatim}
(defun finalize-measures (l)
  (let ((objet-petit-a (collect-measures l)))
    (unless (zerop (length objet-petit-a))
      (flatten
       (mapcar #'cl-csv:read-csv
	       (mapcar #'clean-measures objet-petit-a))))))
\end{verbatim}
\subsection{collect-see-also}
\label{sec-3-7}
Collect strings from the results of \texttt{preprocess-english} that begin with "see
also".
\begin{verbatim}
(defun collect-see-also (l)
  (iterate (for s in l)
    (when (and (stringp s)
	       (< 8 (length s))
	       (string= (subseq s 0 8) "see also"))
      (collect s))))
\end{verbatim}
\subsection{clean-english}
\label{sec-3-8}
Remove all entries that are not themselves translations of the term,
but relate to either units of measurement, or hint to related terms.
\begin{verbatim}
(defun clean-english (l)
  (remove-if (lambda (s)
	       (or
		(and (< 8 (length s))
		     (or (string= (subseq s 0 8) "see also")
			 (string= (subseq s 0 9) "(see also")))
		(and (< 4 (length s))
		     (string= (subseq s 0 3) "CL:"))))
	     l))
\end{verbatim}
\subsection{eleml-to-struct}
\label{sec-3-9}
Break up the s-expressionized CSV line and name the elements, then perform
various operations on each elements, including further breaking up into
references to other items,
\begin{verbatim}
(defun eleml-to-struct (l)
  (destructuring-bind (hsk hanzi pinyin description) l
    (let* ((pre-english (preprocess-english description))
	   (units       (finalize-measures  pre-english))
	   (see-also    (collect-see-also   pre-english))
	   (english     (clean-english      pre-english)))
      (make-vocab-entry :hsk     (read-from-string hsk)
			:hanzi   hanzi
			:pinyin  pinyin
			:english english
			:units   units
			:seealso see-also))))
\end{verbatim}
\subsection{batch-add-table}
\label{sec-3-10}
Copy the entire result of a \texttt{parse-csv} operation into a hash table using the
predefined functions above.
\begin{verbatim}
(defun batch-add-table (l)
  (dolist (lx l)
    (puthash (gen-ht-key 'zh-index)
	     *zh-hash-table*
	     (eleml-to-struct lx))))
\end{verbatim}
\section{Data-store utility functions}
\label{sec-4}
\subsection{element-of-truth}
\label{sec-4-1}
Check a list for any non-nil values.
\begin{verbatim}
(defun element-of-truth (l)
  (member t (mapcar (lambda (x)
		      (when x t))
		    l)))
\end{verbatim}
\subsection{gen-ht-key}
\label{sec-4-2}
\texttt{gen-ht-key} creates the keys used for labeling objects in the hash table.
\begin{verbatim}
(defun gen-ht-key (prefix)
  (let ((the-sym-name (format nil "~D-~D" prefix (incf *vocab-key-count*))))
    (intern the-sym-name :cl-cvd)))
\end{verbatim}
\subsection{key-exists-p}
\label{sec-4-3}
Test to see if a key is already assigned within a hash-table
\begin{verbatim}
(defun key-exists-p (key table)
  (if (gethash key table)
      t
      nil))
\end{verbatim}
\subsection{puthash}
\label{sec-4-4}
Wrap the \texttt{setf} clause in a function for adding/modifying entries in a hash-table
\begin{verbatim}
(defun puthash (key table object)
  (setf (gethash key table) object))
\end{verbatim}
\subsection{hash-table searching functions}
\label{sec-4-5}
\subsubsection*{hsk-apropos}
\label{sec-4-5-1}
Search for and collect items that match a specified \href{http://en.wikipedia.org/wiki/Hanyu_Shuiping_Kaoshi}{HSK} level.
\begin{verbatim}
(defun hsk-apropos (level)
  (declare (fixnum level))
  (loop :for key :being the hash-keys :of *zh-hash-table*
	:for val :being the hash-value :of *zh-hash-table*
	:when (= level (the fixnum (vocab-entry-hsk val)))
	  :collect key))
\end{verbatim}
\subsubsection*{zh-apropos}
\label{sec-4-5-2}
Search the hash table for a matching Hanzi entry and return it with the hash key
associated with the vocabulary entry found in a list in the form \texttt{(<key>
<vocab-entry>)}.
\begin{verbatim}
(defun zh-apropos (zh-string)
  (declare (string zh-string))
  (loop :for key :being the hash-keys :of *zh-hash-table*
	:for val :being the hash-value :of *zh-hash-table*
	:when (scan zh-string (vocab-entry-hanzi val))
	  :collect (list key val)))
\end{verbatim}
\subsubsection*{zh-apropos-key}
\label{sec-4-5-3}
Find vocabulary entries where the provided \texttt{zh-string} is at least a subset of
the string stored in the entry's \texttt{:hanzi} slot. Return a list of hash-keys of
the relevant vocabulary entries.
\begin{verbatim}
(defun zh-apropos-key (zh-string)
  (declare (string zh-string))
  (loop :for key :being the hash-keys  :of *zh-hash-table*
	:for val :being the hash-value :of *zh-hash-table*
	:when (scan zh-string (vocab-entry-hanzi val))
	  :collect key))
\end{verbatim}
\subsubsection*{en-apropos}
\label{sec-4-5-4}
Find a vocab entry which contains a specified substring within its \texttt{:english} slot.
\begin{verbatim}
(defun en-apropos (en-string)
  (declare (string en-string))
  (loop :for key :being the hash-keys :of *zh-hash-table*
	:for val :being the hash-value :of *zh-hash-table*
	:when (element-of-truth
	       (mapcar (lambda (s)
			 (scan en-string s))
		       (vocab-entry-english val)))
	  :collect (list key val)))
\end{verbatim}
\subsubsection*{en-apropos-word}
\label{sec-4-5-5}
Find a vocab entry which contains a discreet word, separated by punctuation on
either side, or at either end of the whole sequence.
\begin{verbatim}
(defun en-apropos-word (en-word)
  (declare (string en-word))
  (loop :for key :being the hash-keys :of *zh-hash-table*
	:for val :being the hash-value :of *zh-hash-table*
	:when (element-of-truth
	       (mapcar (lambda (s)
			 (find-word-in-string en-word s))
		       (vocab-entry-english val)))
	  :collect (list key val)))
\end{verbatim}
\begin{itemize}
\item find-word-in-string
\label{sec-4-5-5-1}
Find a whole word within a provided string, delineated by an end of the
\texttt{target-string} or any predefined punctuation mark as defined within the
\texttt{punctuation-p} enclosed functions.
\begin{verbatim}
(defun find-word-in-string (word target-string)
  (declare (string word target-string))
  (multiple-value-bind (word-begin word-end) (scan word target-string)
    (when (and word-begin word-end)
      (cond ((string= word target-string) word)
	    ((and (or (zerop word-begin)
		      (punctuation-p (char target-string (- word-begin 1))))
		  (or (= (length target-string) word-end)
		      (punctuation-p (char target-string word-end))))
	     word)))))
\end{verbatim}
\item punctuation-p
\label{sec-4-5-5-2}
Define a set of functions for retrieving and manipulating a stored list of
punctuation-marks and white-space characters.
\begin{verbatim}
(let ((punctuations '(#\SPACE #\Tab
		      #\.     #\,
		      #\;     #\:
		      #\/     #\\
		      #\|     #\!
		      #\-     #\_
		      #\(     #\) 
		      #\{     #\}
		      #\[     #\]
		      #\~     #\`
		      #\<     #\>
		      #\?     #\&
		      #\"     #\+
		      #\=)))

  (defun punctuation-p (chr)
    (member chr punctuations))

  (defun defpunct (chr)
    (unless (punctuation-p chr)
      (push chr punctuations)))

  (defun rempunct (chr)
    (when (punctuation-p)
      (setf punctuations (delete chr punctuations))))

  (defun get-punctuation ()
    punctuations))
\end{verbatim}
\end{itemize}
\subsection{count-spaces}
\label{sec-4-6}
Determine the complexity of an example by counting the spaces in a string. This
is used to determine if one should be expected to enter the english equivalent
of a selected Chinese text sample.
\begin{verbatim}
(defun count-spaces (str)
  (let ((space-count 0))
    (iterate (for chr in-string str)
      (when (char= chr #\SPACE)
	(incf space-count))
      (finally (return space-count)))))
\end{verbatim}
\section{Entry manipulation}
\label{sec-5}
\subsection{add-entry}
\label{sec-5-1}
Create a new instance of \texttt{vocab-entry} and install it into the primary
hash-table with a unique key.
\begin{verbatim}
(defun add-entry (&key hanzi pinyin english (hsk 0) (hash-table *zh-hash-table*))
  (puthash (gen-ht-key 'zh-index)
	   hash-table
	   (make-vocab-entry :hanzi   hanzi
			     :pinyin  pinyin
			     :english english
			     :hsk     hsk)))
\end{verbatim}
\subsection{revise-entry}
\label{sec-5-2}
Modify an entry by accepting a field parameter, and a replacement value.
\begin{verbatim}
(defun revise-entry (&key key field new-data (hash-table *zh-hash-table*))
  (let ((the-object (gethash key hash-table)))
    (case field
      ((hanzi)   (setf (vocab-entry-hanzi   the-object) new-data))
      ((pinyin)  (setf (vocab-entry-pinyin  the-object) new-data))
      ((english) (setf (vocab-entry-english the-object) new-data)))))
\end{verbatim}
\subsection{append-english}
\label{sec-5-3}
Append additional English terms to the \texttt{:english} slot in a \texttt{vocab-entry}
instance.
\begin{verbatim}
(defun append-english (english-strings &key key (hash-table *zh-hash-table*))
  (let ((the-object (gethash key hash-table)))
    (revise-entry (append (vocab-entry-english the-object) english-strings)
		  :key key
		  :field 'english)))
\end{verbatim}
\subsection{update-score}
\label{sec-5-4}
Update the score stored in a \texttt{vocab-entry} instance based on the results of
\texttt{check-answer} and \texttt{score-result}.
\begin{verbatim}
(defun update-score (answer hash-key test-type &key (hash-table *zh-hash-table*))
  (let ((vocab-entry (gethash hash-key hash-table)))
    (setf (vocab-entry-score vocab-entry)
	  (+ (vocab-entry-score vocab-entry)
	     (score-result (check-answer answer vocab-entry test-type))))
    (setf (vocab-entry-date vocab-entry)
	  (get-universal-time))
    (incf (vocab-entry-reps vocab-entry))))
\end{verbatim}
\section{Storage}
\label{sec-6}
\subsection{Saving}
\label{sec-6-1}
\subsubsection*{save-ht-vocab}
\label{sec-6-1-1}
\texttt{save-ht-vocab} dumps the raw hash-table to a file, pretty printed for nicer viewing.
\begin{verbatim}
(defun save-ht-vocab (&key (vocab-table *zh-hash-table*) (filename "zh-save.raw"))
  (with-open-file (out filename
		       :direction :output
		       :if-exists :supersede)
    (with-standard-io-syntax
      (pprint vocab-table out))))
\end{verbatim}
\subsubsection*{export-vocab}
\label{sec-6-1-2}
The \texttt{export-vocab} function arose out of a finding that hash-table objects
differ slightly between Common Lisp implementations.
\begin{verbatim}
(defun export-vocab (&key (vocab-table *zh-hash-table*) (filename "zh-portable.raw"))
  (labels ((destructure-vocab (x y)
	     (push (list x y) the-alist)))
    (let (the-alist)
      (maphash #'destructure-vocab vocab-table)
      (with-open-file (out filename
			   :direction :output
			   :if-exists :supersede)
	(with-standard-io-syntax
	  (pprint the-alist out))))))
\end{verbatim}
\subsection{Loading}
\label{sec-6-2}
\subsubsection*{load-ht-vocab}
\label{sec-6-2-1}
This function reads in a file and sets the \texttt{*zh-hash-table*} to the value of the
contents of that file.
\begin{verbatim}
(defun load-ht-vocab (&optional (filename "zh-save.raw") (vocab-variable *zh-hash-table*))
  (with-open-file (in filename)
    (with-standard-io-syntax
      (setf vocab-variable (read in))))
  (setf *vocab-key-count* (hash-table-count *zh-hash-table*)))
\end{verbatim}
\subsubsection*{import-vocab}
\label{sec-6-2-2}
The obvious counterpart to \texttt{export-vocab}.
\begin{verbatim}
(defun import-vocab (&key (vocab-table *zh-hash-table*) (filename "zh-portable.raw"))
  (labels ((structure-vocab (l)
	     (puthash (car l) vocab-table (cadr l))))
    (with-open-file (in filename)
      (with-standard-io-syntax
	(mapcar #'structure-vocab (read in))))
    (setf *vocab-key-count* (hash-table-count *zh-hash-table*))))
\end{verbatim}
\subsection{Converting}
\label{sec-6-3}
When moving between Lisp implementations, you cannot keep the same hash-table
object in plain-text format and expect to be able to load it, so this must be
executed in order to use your data-set when migrating.
\begin{verbatim}
(defun convert-vocab ()
  (let ((voctemp (make-hash-table)))
    (import-vocab :vocab-variable voctemp)
    (save-ht-vocab :vocab-table voctemp)))
\end{verbatim}
\section{MP3 file Matching and Playback}
\label{sec-7}
MP3s and the original data-set were provided by \texttt{lingomi}.

\subsection{fill-mp3-paths}
\label{sec-7-1}
Set the variable \texttt{*mp3dir*} to be a list of paths to each of the MP3s for the
vocab tests.
\begin{verbatim}
(defun fill-mp3-paths ()
  (setf *mp3dir* (directory #P"~/chinese/hsk_mp3/*.mp3"))
  nil)
\end{verbatim}
\subsection{matching vocab entries to mp3s}
\label{sec-7-2}
\subsubsection*{find-mp3-path}
\label{sec-7-2-1}
Search a list of mp3 files for a match with a predefined pinyin string.
\begin{verbatim}
(defun find-mp3-path (match-name)
  (iterate (for elt in *mp3dir*)
    (finding elt such-that (scan match-name (namestring elt)))))
\end{verbatim}
\subsubsection*{find-matching-mp3}
\label{sec-7-2-2}
Match a given vocabulary key to a list of mp3 files
\begin{verbatim}
(defun find-matching-mp3 (vocab-key)
  (let* ((vocab-entry (gethash vocab-key *zh-hash-table*))
	 (pinyin (vocab-entry-pinyin vocab-entry))
	 (nospace (regex-replace " " pinyin ""))
	 (match-name (concatenate 'string "-" nospace "-"))
	 (mp3-path (find-mp3-path match-name)))
    (when mp3-path
      (push (list vocab-key
		  (namestring mp3-path))
	    *mp3-alist*))))
\end{verbatim}
\subsubsection*{find-active-vocab-mp3s}
\label{sec-7-2-3}
Look for mp3s which match the contents of the \texttt{*mp3dir*} variable, if it is not
already in the \texttt{*mp3-alist*}, add it in the form of \texttt{(KEY PATH-TO-MP3)}.
\begin{verbatim}
(defun find-active-vocab-mp3s (&optional (source-list *mp3dir*))
  (mapcar (lambda (key)
	    (unless (assoc key *mp3-alist*)
	      (find-matching-mp3 key)))
	  source-list))
\end{verbatim}
\subsubsection*{play-mp3}
\label{sec-7-2-4}
Launch a thread that runs a program with the appropriate filename as returned by
an association list lookup.
\begin{verbatim}
(defun play-mp3 (key)
  (bordeaux-threads:make-thread (lambda ()
				  (run "/usr/bin/mpg123"
				       (cdr (assoc key *mp3-alist*))))
				:name "mp3 playback thread"))
\end{verbatim}
\section{Testing Facilities}
\label{sec-8}
\subsection{set comparisons}
\label{sec-8-1}
\begin{verbatim}
(defun my-subset? (set-x set-y)
  (not (set-difference set-x set-y)))
\end{verbatim}
\begin{verbatim}
(defun set-equal? (set-x set-y)
  (and (my-subset? set-x set-y)
       (my-subset? set-y set-x)))
\end{verbatim}
\subsection{load-from-hsk}
\label{sec-8-2}
Useful for bootstrapping vocab-element selection.
\begin{verbatim}
(defun load-from-hsk (hsk-val &optional (n 10))
  (setf *test-pool*
	(subseq (reverse (hsk-apropos hsk-val))
		0
		n)))
\end{verbatim}
\subsection{add-vocabs}
\label{sec-8-3}
\begin{verbatim}
(defun add-vocabs (hsk &key (count 5))
  (let ((pool     (reverse (hsk-apropos hsk)))
	(p-length (length *test-pool*)))
    (iterate (for elt in pool)
      (unless (member elt *test-pool*)
	(when (<= (length *test-pool*)
		  (+ p-length count))
	  (push elt *test-pool*))))))
\end{verbatim}
\subsection{enumerate-qualified-elements}
\label{sec-8-4}
Check the number of elements that have qualified since the last test occurred,
This is used to check to see if the minimal number of elements required for a
test can be called in without overlapping cooldown-times.
\begin{verbatim}
(defun enumerate-qualified-elements ()
  (length (remove-if-not #'qualified-p *test-pool*)))
\end{verbatim}
\subsection{refil-testing-pool}
\label{sec-8-5}
\begin{verbatim}
(defun refil-testing-pool (hsk upper-bound)
  (add-vocabs hsk (- upper-bound (enumerate-qualified-elements))))
\end{verbatim}

\subsection{hsk-spillover}
\label{sec-8-6}
When a testing level is exhausted, pull more from the next level up.
If there are no more levels, don't increment.
\begin{verbatim}
(defun hsk-spillover ()
  (if (and (hsk-apropos (+ *current-hsk-level* 1))
	   (set-equal-p *test-pool* (hsk-apropos *current-hsk-level*)))
      (incf *current-hsk-level*)
      (format nil "Takeshi: ``Amazing!''")))
\end{verbatim}
\subsection{Vocab element qualification}
\label{sec-8-7}
\subsubsection*{english-sensible-p}
\label{sec-8-7-1}
Check to see if any constituents of the english parameter of a particular entry
can be expected to be remembered verbatim and entered when prompted for an
English answer. Perhaps this could be mitigated with a check against a digital
thesaurus.
\begin{verbatim}
(defun english-sensible-p (vocab-entry)
  (element-of-truth (mapcar (lambda (s)
			      (< (count-spaces s) 2))
			    (vocab-entry-english vocab-entry))))
\end{verbatim}
\subsubsection*{sensible-tests}
\label{sec-8-7-2}
A bit crude, but return a list of appropriate tests based on the response of
\texttt{english-sensible-p}.
\begin{verbatim}
(defun sensible-tests (vocab-element)
  (if (english-qualified-p vocab-element)
      (list 'english 'hanzi 'pinyin)
      (list 'hanzi 'pinyin)))
\end{verbatim}
\subsubsection*{qualified-p}
\label{sec-8-7-3}
Test to see which vocabulary elements qualify for testing at a given time.
\begin{verbatim}
(defun qualified-p (vocab-struct)
  (and (> 10 (vocab-entry-reps vocab-struct))
       (> (get-universal-time)
	  (vocab-entry-date vocab-struct))))
\end{verbatim}
\subsubsection*{set-next-test}
\label{sec-8-7-4}
Set the \texttt{:date} slot in a given vocab structure to the next scheduled test based
upon the number of times it has been correctly answered.
\begin{verbatim}
(defun set-next-test (vocab-struct)
  (setf (vocab-entry-date vocab-struct)
	(schedule-next-test (vocab-entry-reps vocab-struct))))
\end{verbatim}
\subsection{Presentation}
\label{sec-8-8}
\subsubsection*{show-challenge}
\label{sec-8-8-1}
Take a \texttt{field} and \texttt{key}, and respond with a string from the requested
field. A field value of \texttt{english} will return a random string from the list
located in the \texttt{:english} field of the selected \texttt{vocab-entry}, and \texttt{english-all}
will return a string containing all the elements of the list. A value of
\texttt{pinyin} will return a pinyin string, and \texttt{hanzi} will return the Chinese
ideographs.
\begin{verbatim}
(defun show-challenge (&key field key (hash-table *zh-hash-table*))
  (let ((the-object (gethash key hash-table)))
    (case field
      ((english)     (nth (random (length (vocab-entry-english the-object)))
			  (vocab-entry-english the-object)))
      ((english-all) (format nil "~{~A~^, ~}." (vocab-entry-english the-object)))
      ((pinyin)      (vocab-entry-pinyin the-object))
      ((hanzi)       (vocab-entry-hanzi the-object)))))
\end{verbatim}
\subsubsection*{take-answer}
\label{sec-8-8-2}
A simple silly test.
\begin{verbatim}
(defun take-answer (&key test)
  (format t "~D> " test)
  (read-line))
\end{verbatim}
\subsection{List construction}
\label{sec-8-9}
\subsubsection*{construct-test-list}
\label{sec-8-9-1}
Build up a sample of vocab items for a test battery.
\begin{verbatim}
(defun construct-test-list (length &key (test-pool *test-pool*) (vocab *zh-hash-table*))
  "Construct a test list of LENGTH members"
  (let ((repeat 0)
	(result))
    (iterate (for key in test-pool)
      (if (= repeat length)
	  result
	  (when (qualified-p (gethash key vocab))
	    (incf repeat)
	    (collect key into result at beginning))))))
\end{verbatim}
\subsubsection*{reconstruct-test-pool}
\label{sec-8-9-2}
Rebuild the testing pool from the base vocab library by searching for items that
have already been seen in practice.
\begin{verbatim}
(defun reconstruct-test-pool ()
  (maphash (lambda (key val)
	     (when (< 1 (vocab-entry-reps val))
	       (push key *test-pool*)))
	   *zh-hash-table*))
\end{verbatim}
\subsection{Scoring}
\label{sec-8-10}
\subsubsection*{string-in-list-p}
\label{sec-8-10-1}
Test to see if a list contains a specified string.
\begin{verbatim}
(defun string-in-list-p (string l)
  (iterate (for s in l)
    (when (string= s string)
      l)))
\end{verbatim}
\subsubsection*{check-answer}
\label{sec-8-10-2}
Test a provided answer for correctness against data stored in a vocab-entry instance.
\begin{verbatim}
(defun check-answer (answer vocab-entry test-type)
  (cond ((and (equalp test-type 'english)
	      (string-in-list-p answer (vocab-entry-english vocab-entry))))
	((and (equalp test-type 'hanzi)
	      (string= answer (vocab-entry-hanzi vocab-entry))))
	((and (equalp test-type 'pinyin)
	      (string= answer (vocab-entry-pinyin vocab-entry))))
	((not (member test-type '(english hanzi pinyin)))
	 (error "Unknown test-type"))))
\end{verbatim}
\subsubsection*{score-result}
\label{sec-8-10-3}
Return a complex number, depending the state of \texttt{result}, that is added to the
score stored in a specific \texttt{vocab-entry} structure. The left side of the complex
is Correct, the right is Incorrect.
\begin{verbatim}
(defun score-result (result)
  (if result
      1
      #C(0 1)))
\end{verbatim}
\subsubsection*{determine-offset}
\label{sec-8-10-4}
,Determine the offset for scheduling from anywhere between minutes to weeks based
on the ratio between the real and imaginary components of the complex number
stored in the \texttt{:score} slot. This is used to grade understanding between at
least four categories: unknown, poorly known, somewhat known, and known.
\begin{verbatim}
(defun determine-offset (c)
    (let ((ratio (/ (realpart c) (imagpart c))))
      (cond ((<= ratio 1)  'unknown)
	    ((<= ratio 2)  'poor)
	    ((<= ratio 5)  'medium)
	    ((<= ratio 10) 'good))))
\end{verbatim}
\subsubsection*{schedule-next-test}
\label{sec-8-10-5}
Determine when a word should be tested next based on the number of repetitions,
and adjust this based on the score.
\begin{verbatim}
(defun schedule-next-test (reps score)
  (round
   (+ (get-universal-time)
      (* (+ 7200                          ; two hours in seconds
	    (case (determine-offset score)
	      ((unknown) 3600)            ; one hour in seconds
	      ((poor)    7200)            ; two hours in seconds
	      ((medium)  10800)           ; three hours in seconds
	      ((good)    18000)           ; Five hours in seconds
	      ((t)       28800)           ; Eight hours in seconds;
	      ((nil)     28800))          ; for compiler optimization.
	    (expt phi (/ reps 3)))))))
\end{verbatim}
\subsection{display-and-play}
\label{sec-8-11}
Print the Challenge to the screen, then prompt the user for the selected test,
and play the sound file associated with the vocab entry. Update the score stored
in the vocab-entry structure to reflect the correctness of the answer.
\begin{verbatim}
(defun display-and-play (&key key from for)
  (let ((goal      (show-challenge :field for :key key))
	(challenge (show-challenge :field from :key key)))
    (play-mp3 key)
    (format t "~D~%~D> " challenge for)
    (let* ((vocab-entry (gethash key *zh-hash-table*))
	   (results     (check-answer (get-answer) vocab-entry for))
	   (reps        (vocab-entry-reps vocab-entry)))
      (setf (vocab-entry-score vocab-entry)
	    (+ (score-result results)
	       (vocab-entry-score vocab-entry)))
      (if results
	  (progn (setf (vocab-entry-date vocab-entry)
		       (schedule-next-test reps
					   (vocab-entry-score vocab-entry)))
		 (incf reps))
	  (progn (setf *test-pool*
		       (reverse (cons key (reverse *test-pool*))))
		 goal)))))
\end{verbatim}
\begin{itemize}
\item get-answer
\label{sec-8-11-0-1}
Just having a call to \texttt{read-line} has some strange effects on program flow, so
I'm wrapping it in a function.
\begin{verbatim}
(defun get-answer ()
  (read-line))
\end{verbatim}
\end{itemize}
\subsection{test-loop}
\label{sec-8-12}
Loop through a set of tests where the test type is indeterminate.
\begin{verbatim}
(defun test-loop (&optional (n 10) (type 'random))
  (let ((test-list (construct-test-list n)))
    (iterate (for elt in test-list)
      (when (> n 0)
	(1- n)
	(case type
	  ((random) (random-test elt))
	  ((t) (display-and-play :key elt :from 'pinyin :for 'hanzi)))))))
\end{verbatim}
\subsection{random-test}
\label{sec-8-13}
\begin{verbatim}
(defun random-test (key)
  (let* ((test-list (list 'hanzi 'pinyin 'english))
	 (crazy-english (list 'hanzi 'pinyin))
	 (sane-for (if (english-sensible-p (gethash key *zh-hash-table*))
		       (nth (random (length test-list)) test-list)
		       (nth (random (length crazy-english)) crazy-english)))
	 (rest-tests (delete sane-for test-list))
	 (from (nth (random (length rest-tests)) rest-tests)))
    (display-and-play :key key :from from :for sane-for)))
\end{verbatim}
% Emacs 24.3.1 (Org mode 8.2.10)
\end{document}
